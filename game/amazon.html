<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Amazons</title>
  <style>
    :root{--size:60px;--light:#f0d9b5;--dark:#b58863;--highlight:#ffe066}
    body{font-family:system-ui,Segoe UI,Arial;display:flex;flex-direction:column;align-items:center;padding:18px}
    h1{margin:6px 0 12px}
    #controls{margin-bottom:8px;display:flex;gap:10px;align-items:center}
    button{padding:6px 10px;font-size:14px}
    #status{font-weight:600}
    .board{display:grid;grid-template-columns:repeat(8, var(--size));grid-template-rows:repeat(8,var(--size));border:4px solid #444;position:relative}
    .cell{width:var(--size);height:var(--size);display:flex;align-items:center;justify-content:center;font-size:28px;cursor:pointer;user-select:none;position:relative}
    .piece{width:36px;height:36px;border-radius:50%;display:inline-block;box-sizing:border-box}
    .piece.white{background:#fff;border:2px solid #ddd}
    .piece.black{background:#222;border:2px solid #111}
    .cell.light{background:var(--light)}
    .cell.dark{background:var(--dark)}
    .cell.available{box-sizing:border-box}
    .cell.available::after{content:'';position:absolute;inset:0;background:rgba(0,0,0,0.12);pointer-events:none;border-radius:0}
    .cell.arrow{color:#444}
    .cell.blocked{color:inherit}
    .cell.blocked::after{content:'×';position:absolute; font-size:44px;line-height:1;left:50%;top:50%;transform:translate(-50%,-50%);background:none;pointer-events:none;border:0;padding:0;margin:0}
    /* make × contrast with the underlying checker color and slightly larger */
    .cell.light.blocked::after{color:#444;font-size:50px}
    .cell.dark.blocked::after{color:#444;font-size:50px;text-shadow:0 1px 0 rgba(0,0,0,0.15)}
    .moving-piece{position:absolute;z-index:60;pointer-events:none}
    /* overlay modal when game over */
    .overlay{position:fixed;inset:0;background:rgba(0,0,0,0.45);display:flex;align-items:center;justify-content:center;z-index:80;visibility:hidden;opacity:0;transition:opacity 200ms}
    .overlay.show{visibility:visible;opacity:1}
    .modal{background:#fff;padding:18px 22px;border-radius:10px;box-shadow:0 8px 24px rgba(0,0,0,0.25);min-width:260px;text-align:center}
    .modal h2{margin:0 0 8px;font-size:18px}
    .modal button{margin-top:8px}
    .legend{margin-top:12px;font-size:14px}
    /* Responsive adjustments for small screens */
    .board{width:calc(var(--size) * 8);height:calc(var(--size) * 8);}
    @media (max-width: 600px){
      :root{--size: calc((100vw - 36px) / 8);} /* fit 8 cells into viewport with some padding */
      body{padding:10px}
      .modal{min-width:unset;width:90%;padding:14px}
      .legend{font-size:13px}
      .cell{font-size:22px}
      .piece{width:calc(var(--size) * 0.6);height:calc(var(--size) * 0.6)}
    }
  </style>
  <script src="../src/jquery.min.js"></script>
  <script src="https://cdn.ably.com/lib/ably.min-1.js"></script>
</head>
<body>
  <h1>Amazons</h1>
  <div id="controls">
    <div id="status">当前回合：白方 ♕</div>
    <label>模式: <select id="mode"><option value="pve_first">单人（玩家先手）</option><option value="pve_second">单人（玩家后手）</option><option value="pvp">双人</option><option value="ai_vs_ai">电脑对局</option></select></label>
    <label>AI难度: <select id="level"><option value="easy">简单</option><option value="medium" selected>中等</option><option value="hard">困难</option></select></label>
  </div>
  <div id="board" class="board" role="application" aria-label="Amazon 棋盘"></div>
  <div class="legend">提示：先点击你的棋子，点击目标位置移动，然后点击放置障碍的位置。</div>

  <div id="overlay" class="overlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true">
      <h2 id="overlay-title">游戏结束</h2>
      <div id="overlay-msg">胜者：黑方</div>
      <div style="margin-top:10px"><button id="overlay-reset">重新开始</button></div>
    </div>
  </div>

  <script>
  (function(){
    const SIZE = 8;
    const EMPTY = 0, WHITE = 1, BLACK = 2, ARROW = 3;
    const boardEl = document.getElementById('board');
    const statusEl = document.getElementById('status');
    // hide current-turn until a match is started
    statusEl.style.display = 'none';

    let board = new Array(SIZE*SIZE).fill(EMPTY);
    let currentPlayer = WHITE; // WHITE starts
    let selected = null; // selected amazon index during move
    let phase = 'select'; // 'select' | 'arrow'
    let aiEnabled = false;
    let aiColor = BLACK; // which color AI plays when aiEnabled
    let aiDelay = 0; // ms delay before AI moves（避免重置后立刻阻塞UI）
    let aiTimeLimit = 1200; // ms for search budget
    let aiMaxDepth = 3;     // maximum search depth
    let gameOver = false;
    let isAnimating = false;
    let runId = 0; // 每次新开局自增，旧回调失效
    let aiTimer = null; // 待触发的AI计时器
    let animTimer = null; // 动画兜底计时器
    let searchWorker = null; // Web Worker for AI search
    // --- Online play state ---
    let onlineEnabled = false; // whether online mode is active for this session
    let onlineRoom = null;
    let onlineAbly = null;
    let onlineChannel = null;
    let onlineClientId = (crypto && crypto.randomUUID) ? crypto.randomUUID() : Math.random().toString(36).slice(2,9);
    let onlinePeers = new Map(); // discovered peers
    let onlineHeartbeat = null;
    let onlineLocalColor = null; // WHITE or BLACK
    let onlineStarted = false; // whether an online match has been started in this room
    let pendingMoveFrom = null; // used to store origin during animated move
    let pendingMoveTo = null;
    let gameStarted = false; // whether current match is active (started by Start or online start)
    let isMyTurn = false; // for online: whether it's currently this client's turn

    function idx(r,c){return r*SIZE+c}
    function rc(i){return [Math.floor(i/SIZE), i%SIZE]}

    function setupInitial(){
      runId++;
      cancelAllAsync();
      board.fill(EMPTY);
      // Place 4 white amazons at positions specified by user (0-based): (0,2),(2,0),(0,5),(2,7)
      const whites = [[0,2],[2,0],[0,5],[2,7]];
      // horizontal symmetry (flip rows) for black pieces
      const blacks = whites.map(([r,c]) => [7 - r, c]);
      for(const [r,c] of whites) board[idx(r,c)] = WHITE;
      for(const [r,c] of blacks) board[idx(r,c)] = BLACK;
      currentPlayer = WHITE; selected = null; phase='select'; gameOver=false; isAnimating=false;
      // Start disabled until user clicks '开始' (or online start). Prevent local moves before start.
      gameStarted = false;
      isMyTurn = false;
      render();
      // if AI plays first, trigger
      checkGameOverAndMaybeTriggerAI();
    }

    function render(){
      boardEl.innerHTML = '';
      for(let r=0;r<SIZE;r++){
        for(let c=0;c<SIZE;c++){
          const i = idx(r,c);
          const cell = document.createElement('div');
          cell.className = 'cell '+(((r+c)%2===0)?'light':'dark');
          cell.dataset.index = i;
          if(board[i]===WHITE){
            const p = document.createElement('span'); p.className = 'piece white'; cell.appendChild(p);
          } else if(board[i]===BLACK){
            const p = document.createElement('span'); p.className = 'piece black'; cell.appendChild(p);
          } else if(board[i]===ARROW){
            // keep blocked background but remove dot
            cell.classList.add('blocked');
          }
          boardEl.appendChild(cell);
        }
      }
      updateStatus();
    }

    function showOverlay(title,msg){
      const ov = document.getElementById('overlay');
      document.getElementById('overlay-title').textContent = title;
      document.getElementById('overlay-msg').textContent = msg;
      ov.classList.add('show'); ov.setAttribute('aria-hidden','false');
      // visually disable board
      boardEl.style.filter = 'brightness(0.75)';
      boardEl.style.pointerEvents = 'none';
    }

    function hideOverlay(){
      const ov = document.getElementById('overlay');
      ov.classList.remove('show'); ov.setAttribute('aria-hidden','true');
      boardEl.style.filter = ''; boardEl.style.pointerEvents = '';
    }

    let aiBoth = false; // when true both sides are AI
    function setModeFromUI(){
      const mode = document.getElementById('mode').value;
      aiBoth = false;
      if(mode === 'pvp') { aiEnabled = false; aiColor = null; }
      else if(mode === 'pve_first') { aiEnabled = true; aiBoth = false; aiColor = BLACK; }
      else if(mode === 'pve_second') { aiEnabled = true; aiBoth = false; aiColor = WHITE; }
      else if(mode === 'ai_vs_ai') { aiEnabled = true; aiBoth = true; aiColor = null; }
    }

    function setLevelFromUI(){
      const lv = document.getElementById('level').value;
      if(lv === 'easy'){ aiTimeLimit = 600; aiMaxDepth = 2; }
      else if(lv === 'medium'){ aiTimeLimit = 1200; aiMaxDepth = 3; }
      else { aiTimeLimit = 2000; aiMaxDepth = 4; }
    }

    function updateStatus(){
      if(gameStarted){
        statusEl.style.display = 'inline-block';
        statusEl.textContent = '当前回合：' + (currentPlayer===WHITE? '白方 ♕' : '黑方 ♛');
      } else {
        statusEl.style.display = 'none';
      }
    }

    const DIRS = [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[-1,1],[1,-1],[1,1]];

    function slidesFrom(i, boardState){
      const [r,c] = rc(i);
      const moves = [];
      for(const [dr,dc] of DIRS){
        let nr=r+dr, nc=c+dc;
        while(nr>=0 && nr<SIZE && nc>=0 && nc<SIZE){
          const ni = idx(nr,nc);
          if(boardState[ni] !== EMPTY) break;
          moves.push(ni);
          nr += dr; nc += dc;
        }
      }
      return moves;
    }

    function highlight(list){
      // clear first
      document.querySelectorAll('.cell').forEach(el=>el.classList.remove('available'));
      for(const i of list){
        const el = boardEl.querySelector(`[data-index='${i}']`);
        if(el) el.classList.add('available');
      }
    }

    function clearHighlights(){
      document.querySelectorAll('.cell').forEach(el=>el.classList.remove('available'));
    }

    function handleCellClick(i){
      if(gameOver) return;
      // block input unless gameStarted and (offline or it's our turn online)
      if(!gameStarted) return;
      if(onlineEnabled){ if(!isMyTurn) return; }
      if(aiEnabled && currentPlayer === aiColor) return; // block human input on AI's turn
      if(isAnimating) return;
      // In online player mode, only allow interacting with our own pieces (but still allow clicking available targets)
      if(onlineEnabled && onlineLocalColor){
        const cellEl = boardEl.querySelector(`[data-index='${i}']`);
        const isAvailable = cellEl && cellEl.classList.contains('available');
        if(phase === 'select'){
          // selecting a piece: only allow if it's our color or it's an available move target
          if(board[i] !== onlineLocalColor && !isAvailable) return;
        }
        // in arrow phase, keep existing logic (available checks below)
      }
      if(phase === 'select'){
        if(board[i] === currentPlayer){
          // clicking the same selected piece cancels selection
          if(selected === i){
            selected = null; clearHighlights();
          } else {
            selected = i;
            const moves = slidesFrom(i, board);
            highlight(moves);
          }
        } else {
          // if clicked an already highlighted move (move target), perform move (animated)
          const el = boardEl.querySelector(`[data-index='${i}']`);
          if(el && el.classList.contains('available') && selected !== null){
            // animated move: from `selected` to `i`
            if(isAnimating) return;
            isAnimating = true;
            const myRun = runId;
            animateMove(selected, i, currentPlayer, ()=>{
              if(myRun!==runId){ isAnimating=false; return; }
              // after move completes, occupy destination and enter arrow phase
              const fromIndex = selected; // record origin
              board[i] = currentPlayer;
              board[fromIndex] = EMPTY;
              // store pending move so we can send it when player places arrow
              pendingMoveFrom = fromIndex;
              pendingMoveTo = i;
              selected = i; // new position before arrow
              phase = 'arrow';
              // compute arrow moves from new pos (treating board as is: amazon occupies new pos)
              const arrows = slidesFrom(selected, board);
              highlight(arrows);
              renderCellsOnly();
              isAnimating = false;
            });
          } else {
            // clicked elsewhere -> cancel selection
            selected = null; clearHighlights();
          }
        }
      } else if(phase === 'arrow'){
        const el = boardEl.querySelector(`[data-index='${i}']`);
        if(el && el.classList.contains('available')){
          // place arrow
          board[i] = ARROW;
          selected = null; phase = 'select';
          clearHighlights();
          currentPlayer = (currentPlayer === WHITE)? BLACK : WHITE;
          render();
          // 如果在线游戏中，发送刚刚完成的移动（from,to,arrow）
          if(onlineEnabled && onlineChannel && pendingMoveFrom !== null && pendingMoveTo !== null){
            const mv = {from: pendingMoveFrom, to: pendingMoveTo, arrow: i, fromClient: onlineClientId, ts: Date.now()};
            try{
              onlineChannel.publish('move', mv, (err)=>{ if(err) console.error('move publish err', err); else console.log('move published', mv); });
            }catch(e){ console.error('publish move exception', e); }
            // clear pending
            pendingMoveFrom = pendingMoveTo = null;
          }
          // after switching player, check game over or let AI move
          checkGameOverAndMaybeTriggerAI();
        } else if (i === selected) {
          // clicked the amazon's current square -> ignore and remain in arrow phase
        } else {
          // clicked an illegal square while in arrow phase -> do nothing
          // preserve moved amazon, keep phase='arrow' and highlights
        }
      }
      // avoid re-rendering the board while a piece animation is active
      if(!isAnimating) renderCellsOnly();
    }

    function checkGameOverAndMaybeTriggerAI(){
      if(gameOver) return;
      // don't run AI logic before a match is started by the player
      if(!gameStarted) return;
      const moves = getAllLegalMoves(currentPlayer, board);
      if(moves.length === 0){
        gameOver = true;
        const winnerColor = (currentPlayer===WHITE? BLACK : WHITE); // opponent wins
        // update status
        statusEl.textContent = '游戏结束：' + (winnerColor===WHITE? '白方' : '黑方') + ' 胜';
        // decide message based on mode (online/offline and AI)
        if(onlineEnabled){
          if(onlineLocalColor){
            if(winnerColor === onlineLocalColor) showOverlay('游戏结束', '你赢了！'); else showOverlay('游戏结束', '你输了……');
          } else {
            showOverlay('游戏结束', '胜者：' + (winnerColor===WHITE? '白方' : '黑方'));
          }
        } else {
          if(aiEnabled && !aiBoth){
            const humanColor = aiColor ? (aiColor === WHITE ? BLACK : WHITE) : WHITE;
            if(winnerColor === humanColor) showOverlay('游戏结束', '你赢了！'); else showOverlay('游戏结束', '你输了……');
          } else {
            showOverlay('游戏结束', '胜者：' + (winnerColor===WHITE? '白方' : '黑方'));
          }
        }
        return;
      }
      if(!aiEnabled) return;
      // 清理旧的AI计时
      if(aiTimer){ clearTimeout(aiTimer); aiTimer = null; }
      const myRun = runId;
      const schedule = (color)=>{
        aiTimer = setTimeout(()=>{ if(myRun===runId && !gameOver) aiMoveFor(color); }, aiDelay);
      };
      if(aiBoth){
        schedule(currentPlayer);
      } else if(currentPlayer === aiColor){
        schedule(aiColor);
      }
    }

    function renderCellsOnly(){
      // update each cell content and classes without rebuilding whole DOM (to preserve highlights)
      for(let i=0;i<SIZE*SIZE;i++){
        const el = boardEl.querySelector(`[data-index='${i}']`);
        if(!el) continue;
        el.classList.remove('blocked');
        el.innerHTML = '';
        if(board[i]===WHITE){ const p = document.createElement('span'); p.className='piece white'; el.appendChild(p); }
        else if(board[i]===BLACK){ const p = document.createElement('span'); p.className='piece black'; el.appendChild(p); }
        else if(board[i]===ARROW){ el.classList.add('blocked'); }
        else { /* empty */ }
      }
      updateStatus();
    }

    boardEl.addEventListener('click', (ev)=>{
      const cell = ev.target.closest('.cell');
      if(!cell) return;
      const i = Number(cell.dataset.index);
      handleCellClick(i);
    });

    // --- Controls: add Start / Resign / Online buttons and modal ---
    const controls = document.getElementById('controls');
    const startBtn = document.createElement('button'); startBtn.id='startBtn'; startBtn.textContent='开始';
    const resignBtn = document.createElement('button'); resignBtn.id='resignBtn'; resignBtn.textContent='认输'; resignBtn.style.display='none';
    const onlineBtn = document.createElement('button'); onlineBtn.id='onlineBtn'; onlineBtn.textContent='联机游戏';
    controls.appendChild(startBtn);
    controls.appendChild(resignBtn);
    controls.appendChild(onlineBtn);
    const exitOnlineBtn = document.createElement('button'); exitOnlineBtn.id='exitOnlineBtn'; exitOnlineBtn.textContent='退出房间'; exitOnlineBtn.style.display='none'; controls.appendChild(exitOnlineBtn);
    // online info element (room and assigned role). Hidden by default
    const onlineInfoEl = document.createElement('div'); onlineInfoEl.id='onlineInfo'; onlineInfoEl.style.marginLeft='8px'; onlineInfoEl.style.fontSize='13px'; onlineInfoEl.style.color='#444'; onlineInfoEl.style.display='none'; controls.appendChild(onlineInfoEl);

    // Reset UI to initial state (shows selectors and start/online, hides resign)
    function resetUIForInitial(){
      try{
        const modeSelect = document.getElementById('mode');
        const levelSelect = document.getElementById('level');
        modeSelect.style.display = '';
        levelSelect.style.display = '';
        // remove value spans if present
        const mv = document.getElementById('modeValueSpan'); if(mv) mv.remove();
        const lv = document.getElementById('levelValueSpan'); if(lv) lv.remove();
        // restore labels
        try{ modeSelect.parentElement.style.display = ''; }catch(e){}
        levelSelect.parentElement.style.display = '';
        startBtn.style.display = 'inline-block';
        onlineBtn.style.display = 'inline-block';
        resignBtn.style.display = 'none';
        resignBtn.textContent = '认输';
        // not an online session => mark as not started until user clicks Start
        gameStarted = false; isMyTurn = false;
        // reset online started flag
        onlineStarted = false;
        updateStatus();
      }catch(e){ console.warn('resetUIForInitial failed', e); }
    }

    // create simple modal for entering room key
    const onlineModal = document.createElement('div');
    onlineModal.style.position='fixed'; onlineModal.style.left='0'; onlineModal.style.top='0'; onlineModal.style.right='0'; onlineModal.style.bottom='0';
    onlineModal.style.display='none'; onlineModal.style.alignItems='center'; onlineModal.style.justifyContent='center';
    onlineModal.style.background='rgba(0,0,0,0.45)';
    onlineModal.innerHTML = `<div style="background:#fff;padding:18px 20px;border-radius:8px;min-width:280px;text-align:center"><h3>输入 6 位房间 Key</h3><input id='onlineKeyInput' maxlength='6' style='text-transform:uppercase;padding:6px;margin-top:8px;width:60%;text-align:center' placeholder='ABC123'/><div style='margin-top:12px'><button id='onlineJoinConfirm'>加入</button> <button id='onlineJoinCancel'>取消</button></div></div>`;
    document.body.appendChild(onlineModal);
    document.getElementById('onlineJoinCancel').addEventListener('click', ()=>{ onlineModal.style.display='none'; });
    onlineBtn.addEventListener('click', ()=>{ document.getElementById('onlineKeyInput').value=''; onlineModal.style.display='flex'; });
    document.getElementById('onlineJoinConfirm').addEventListener('click', ()=>{
      const v = (document.getElementById('onlineKeyInput').value||'').trim().toUpperCase();
      if(!/^[A-Z0-9]{6}$/.test(v)){ alert('请输入 6 位 (A-Z,0-9) 的 Key'); return; }
      onlineModal.style.display='none';
      startOnline(v);
    });
    // Enter key to confirm
    document.getElementById('onlineKeyInput').addEventListener('keydown', (e)=>{ if(e.key === 'Enter'){ document.getElementById('onlineJoinConfirm').click(); } });

    // Start / Resign handlers
    function beginLocalGame(){
      // configure from UI
      setModeFromUI(); setLevelFromUI();
      // reset board and cancel any async tasks
      cancelAllAsync();
      setupInitial();
      // mark match started for local play
      gameStarted = true; isMyTurn = true;
      // adjust controls: replace selectors with static labels, show resign (or '结束' for AI-vs-AI)
      try{
        const modeSelect = document.getElementById('mode');
        const levelSelect = document.getElementById('level');
        const modeLabel = modeSelect.parentElement;
        const levelLabel = levelSelect.parentElement;
        const modeText = modeSelect.options[modeSelect.selectedIndex].text;
        const levelText = levelSelect.options[levelSelect.selectedIndex].text;
        // hide selects
        modeSelect.style.display = 'none';
        // create or update mode value span
        let mv = document.getElementById('modeValueSpan');
        if(!mv){ mv = document.createElement('span'); mv.id = 'modeValueSpan'; modeLabel.appendChild(document.createTextNode(' ')); modeLabel.appendChild(mv); }
        mv.textContent = modeText;
        // handle level: hide entirely for pvp
        if(modeSelect.value === 'pvp'){
          levelLabel.style.display = 'none';
        } else {
          levelSelect.style.display = 'none';
          let lv = document.getElementById('levelValueSpan');
          if(!lv){ lv = document.createElement('span'); lv.id = 'levelValueSpan'; levelLabel.appendChild(document.createTextNode(' ')); levelLabel.appendChild(lv); }
          lv.textContent = levelText;
          levelLabel.style.display = 'inline-block';
        }
        startBtn.style.display = 'none';
        onlineBtn.style.display = 'none';
        // if both AIs, label should be '结束' and clicking it will end the auto-match
        if(aiBoth){ resignBtn.textContent = '结束'; } else { resignBtn.textContent = '认输'; }
        resignBtn.style.display = 'inline-block';
      }catch(e){ console.warn('beginLocalGame UI adjust failed', e); }
      updateStatus();
      // If AI should move, schedule it
      checkGameOverAndMaybeTriggerAI();
    }

    startBtn.addEventListener('click', ()=>{ beginLocalGame(); });
    exitOnlineBtn.addEventListener('click', ()=>{ stopOnline(); resetUIForInitial(); });
    resignBtn.addEventListener('click', ()=>{
      if(!gameStarted) return;
      // If AI-vs-AI, '认输' acts as '结束' - reset immediately to initial UI without overlay
      if(aiBoth){
        cancelAllAsync(); setupInitial(); resetUIForInitial(); gameStarted = false; return;
      }
      // show overlay
      if(onlineEnabled){ // in online, local user resigns -> they lose
        showOverlay('游戏结束', '你输了……');
        // notify remote that we resigned
        try{ if(onlineChannel) onlineChannel.publish('resign', {from: onlineClientId, ts: Date.now(), loser: onlineClientId}); }catch(e){}
        // cleanup and reset after closing overlay handled by overlay reset button
      } else {
        // offline: if player resigns
        if(!aiEnabled){
          // local two-player: show winner (opposite side)
          const winner = (currentPlayer === WHITE) ? '黑方' : '白方';
          showOverlay('游戏结束', winner + '胜！');
        } else {
          // single-player (human vs AI): player clicked resign => always treated as human loss
          showOverlay('游戏结束', '你输了……');
        }
      }
      gameStarted = false;
    });

    // reset button removed from UI; overlay '重新开始' still available
    document.getElementById('mode').addEventListener('change', ()=>{ setModeFromUI(); });
    document.getElementById('level').addEventListener('change', ()=>{ setLevelFromUI(); });
    document.getElementById('overlay-reset').addEventListener('click', ()=>{ cancelAllAsync(); hideOverlay(); setupInitial(); resetUIForInitial(); });

    // AI helpers
    function cloneBoard(b){ return b.slice(); }

    function getAmazons(color, b){
      const res = [];
      for(let i=0;i<b.length;i++) if(b[i]===color) res.push(i);
      return res;
    }

    function getAllLegalMoves(color, b){
      const res = [];
      const amazons = getAmazons(color, b);
      for(const from of amazons){
        const slides = slidesFrom(from, b);
        for(const to of slides){
          // simulate moving amazon to 'to'
          const tmp = cloneBoard(b);
          tmp[from] = EMPTY; tmp[to] = color;
          const arrows = slidesFrom(to, tmp);
          for(const arrow of arrows){
            res.push({from,to,arrow});
          }
        }
      }
      return res;
    }

    // animation helpers
    function getCellElement(i){ return boardEl.querySelector(`[data-index='${i}']`); }
    function animateMove(from,to,color,cb){
      const $src = $($(getCellElement(from)));
      const $dst = $($(getCellElement(to)));
      if($src.length === 0 || $dst.length === 0){ cb && cb(); return; }
      const srcPiece = $src.find('.piece');
      // compute start/end coordinates in page space
      // use jQuery offsets (document coordinates) to account for scrolling/viewport
      const srcOffset = srcPiece.length ? srcPiece.offset() : $src.offset();
      const dstPiece = $dst.find('.piece');
      const dstCellOffset = $dst.offset();
      const pieceW = srcPiece.length ? srcPiece.outerWidth() : ($src.find('.piece').outerWidth() || $src.outerWidth());
      const pieceH = srcPiece.length ? srcPiece.outerHeight() : ($src.find('.piece').outerHeight() || $src.outerHeight());
      const $moving = $('<span>').addClass('piece ' + (color===WHITE? 'white':'black') + ' moving-piece');
      // set explicit size and absolute page-positioning (use document coordinates)
      $moving.css({position:'absolute', left: srcOffset.left + 'px', top: srcOffset.top + 'px', width: pieceW + 'px', height: pieceH + 'px', 'z-index': 9999});
      // append to body so page coords match
      $(document.body).append($moving);
      // hide original piece visually (keep in DOM to avoid layout change)
      if(srcPiece.length) srcPiece.css('visibility','hidden');
      else $src.find('.piece').css('visibility','hidden');
      // determine destination coordinates: prefer inner piece offset, otherwise center in cell
      let dstLeft, dstTop;
      if(dstPiece.length){
        const dstPieceOffset = dstPiece.offset();
        dstLeft = dstPieceOffset.left;
        dstTop = dstPieceOffset.top;
      } else {
        dstLeft = dstCellOffset.left + ( $dst.outerWidth() - pieceW )/2;
        dstTop = dstCellOffset.top + ( $dst.outerHeight() - pieceH )/2;
      }
      // animate using jQuery built-in .animate on page coords
      const duration = 300; // doubled duration for smoother, slower animation
      $moving.animate({left: dstLeft + 'px', top: dstTop + 'px'}, duration, 'swing', function(){
        // cleanup
        $moving.remove();
        if(srcPiece.length) srcPiece.css('visibility','');
        // call callback (caller will update board state and re-render)
        cb && cb();
      });
      // safety fallback
      if(animTimer) try{ clearTimeout(animTimer); }catch(e){}
      animTimer = setTimeout(()=>{ if($.contains(document, $moving[0])){ $moving.remove(); if(srcPiece.length) srcPiece.css('visibility',''); cb && cb(); } }, duration + 600);
    }

    function aiMoveFor(color){
      if(gameOver) return;
      const moves = getAllLegalMoves(color, board);
      if(moves.length===0){ checkGameOverAndMaybeTriggerAI(); return; }
      // 取消之前的 worker（若在运行）
      if(searchWorker){ try{ searchWorker.terminate(); }catch(e){} searchWorker = null; }
      const myRun = runId;
      // 构建 worker 代码（使用蒙特卡洛树搜索 MCTS）
      const workerCode = `
        const DIRS = [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[-1,1],[1,-1],[1,1]];
        function idx(r,c,s){return r*s+c}
        function rc(i,s){return [Math.floor(i/s), i%s]}
        function slidesFrom(i, boardState, SIZE, EMPTY){
          const [r,c] = rc(i,SIZE);
          const moves = [];
          for(const [dr,dc] of DIRS){
            let nr=r+dr, nc=c+dc;
            while(nr>=0 && nr<SIZE && nc>=0 && nc<SIZE){
              const ni = idx(nr,nc,SIZE);
              if(boardState[ni] !== EMPTY) break;
              moves.push(ni);
              nr += dr; nc += dc;
            }
          }
          return moves;
        }
        function cloneBoard(b){ return b.slice(); }
        function getAmazons(color, b){ const res=[]; for(let i=0;i<b.length;i++) if(b[i]===color) res.push(i); return res; }
        function applyMoveTo(boardSrc, mv, color){ const tmp = cloneBoard(boardSrc); tmp[mv.from]=0; tmp[mv.to]=color; tmp[mv.arrow]=3; return tmp; }
        function getAllLegalMoves(color, b, SIZE){ const res=[]; const amazons = getAmazons(color,b); for(const from of amazons){ const slides=slidesFrom(from,b,SIZE,0); for(const to of slides){ const tmp=cloneBoard(b); tmp[from]=0; tmp[to]=color; const arrows=slidesFrom(to,tmp,SIZE,0); for(const arrow of arrows){ res.push({from,to,arrow}); } } } return res; }

        // Random playout (returns 1 if rootColor wins, 0 otherwise)
        // Modified: 随机走直到出现不可通行的分区（所有连通分区不再同时包含双方棋子），
        // 然后按各自“占有”的格子数判断胜负；若平局则以下一手玩家决定胜负。
        function randomPlayout(board, toMove, rootColor, SIZE){
          let b = cloneBoard(board);
          let player = toMove;
          while(true){
            const moves = getAllLegalMoves(player, b, SIZE);
            if(moves.length === 0){
              // 当前玩家无路可走，另一方获胜
              return (player === rootColor) ? 0 : 1;
            }
            // 随机走一步
            const mv = moves[Math.floor(Math.random()*moves.length)];
            b = applyMoveTo(b, mv, player);

            // 检测基于 8 邻域的连通分区（把 ARROW 视为阻隔）
            const visited = new Array(SIZE*SIZE).fill(false);
            let partitioned = true;
            let whiteArea = 0, blackArea = 0;
            for(let i=0;i<SIZE*SIZE;i++){
              if(visited[i]) continue;
              if(b[i] === 3) continue; // ARROW
              // BFS / DFS 收集连通分区
              const stack = [i]; visited[i] = true;
              let compSize = 0;
              let hasWhite = false, hasBlack = false;
              while(stack.length){
                const cur = stack.pop();
                compSize++;
                if(b[cur] === 1) hasWhite = true;
                else if(b[cur] === 2) hasBlack = true;
                const rcPair = rc(cur, SIZE);
                const r = rcPair[0], c = rcPair[1];
                for(const d of DIRS){
                  const nr = r + d[0], nc = c + d[1];
                  if(nr>=0 && nr<SIZE && nc>=0 && nc<SIZE){
                    const ni = idx(nr,nc,SIZE);
                    if(!visited[ni] && b[ni] !== 3){ visited[ni] = true; stack.push(ni); }
                  }
                }
              }
              if(hasWhite && hasBlack){ partitioned = false; break; }
              if(hasWhite) whiteArea += compSize;
              else if(hasBlack) blackArea += compSize;
            }

            if(partitioned){
              if(whiteArea > blackArea) return (rootColor === 1) ? 1 : 0;
              if(blackArea > whiteArea) return (rootColor === 2) ? 1 : 0;
              // 平局：以下一手玩家（即当前走子后的对方）决定胜负
              const nextPlayer = (player === 1 ? 2 : 1);
              return (nextPlayer === rootColor) ? 1 : 0;
            }

            player = (player===1?2:1);
          }
        }

        // MCTS Node
        function Node(parent, move, playerWhoMoved, board){
          this.parent = parent || null;
          this.move = move || null; // move that led to this node
          this.playerWhoMoved = playerWhoMoved || null;
          this.board = board || null;
          this.children = [];
          this.untriedMoves = null;
          this.wins = 0;
          this.visits = 0;
        }

        Node.prototype.expand = function(move, nextBoard, nextPlayer){
          const child = new Node(this, move, nextPlayer, nextBoard);
          this.children.push(child);
          return child;
        };

        Node.prototype.isFullyExpanded = function(){ return this.untriedMoves && this.untriedMoves.length === 0; };

        Node.prototype.bestChild = function(cParam){
          let best = null; let bestU = -Infinity;
          for(const ch of this.children){
            const u = (ch.wins / (ch.visits||1)) + cParam * Math.sqrt(2*Math.log(this.visits+1)/(ch.visits||1));
            if(u > bestU){ bestU = u; best = ch; }
          }
          return best;
        };

        function mcts(rootBoard, rootPlayer, SIZE, timeLimit, maxDepth){
          const start = Date.now();
          const root = new Node(null, null, (rootPlayer===1?2:1), rootBoard);
          root.untriedMoves = getAllLegalMoves(rootPlayer, rootBoard, SIZE);
          const C = 1.4;
          let iterations = 0;
          while(Date.now() - start < timeLimit){
            iterations++;
            // SELECTION
            let node = root;
            let player = rootPlayer;
            // descend
            while(node.untriedMoves && node.untriedMoves.length === 0 && node.children.length > 0){
              node = node.bestChild(C);
              player = (player===1?2:1);
            }
            // EXPANSION
            if(node.untriedMoves === null){
              node.untriedMoves = getAllLegalMoves(player, node.board, SIZE);
            }
            if(node.untriedMoves && node.untriedMoves.length > 0){
              // Weighted random selection among untried moves using mobility heuristic
              const movesList = node.untriedMoves;
              const weighted = [];
              let totalW = 0;
              for(let mi=0; mi<movesList.length; mi++){
                const mv = movesList[mi];
                const nb = applyMoveTo(node.board, mv, player);
                // mobility: 改为双方移动性之比 (playerMobility / opponentMobility)
                const amazonsP = getAmazons(player, nb);
                let mobP = 0;
                for(const a of amazonsP){ mobP += slidesFrom(a, nb, SIZE, 0).length; }
                const opp = (player===1?2:1);
                const amazonsO = getAmazons(opp, nb);
                let mobO = 0;
                for(const a of amazonsO){ mobO += slidesFrom(a, nb, SIZE, 0).length; }
                const diff = mobP - mobO;
                const w = Math.exp(diff / 20);
                console.log(w);
                weighted.push({mv, nb, w});
                totalW += w;
              }
              // pick by weighted roulette
              let pick = Math.random() * totalW;
              let chosen = null; let chosenIdx = -1;
              for(let k=0;k<weighted.length;k++){
                pick -= weighted[k].w;
                if(pick <= 0){ chosen = weighted[k]; chosenIdx = k; break; }
              }
              if(!chosen){ chosen = weighted[weighted.length-1]; chosenIdx = weighted.length-1; }
              // remove chosen.mv from node.untriedMoves
              const removeIndex = node.untriedMoves.indexOf(chosen.mv);
              if(removeIndex >= 0) node.untriedMoves.splice(removeIndex,1);
              const child = node.expand(chosen.mv, chosen.nb, player);
              node = child;
              player = (player===1?2:1);
            }
            // SIMULATION
            const result = randomPlayout(node.board || root.board, player, rootPlayer, SIZE);
            // BACKPROPAGATION
            let curr = node;
            while(curr !== null){
              curr.visits += 1;
              // if result is win for rootPlayer and child is in its line, add win
              curr.wins += result;
              curr = curr.parent;
            }
          }
          // choose best child by visits
          let best = null; let bestVisits = -1;
          for(const ch of root.children){ if(ch.visits > bestVisits){ bestVisits = ch.visits; best = ch; } }
          return best ? best.move : null;
        }

        self.onmessage = function(ev){ try{ const data = ev.data; const choice = mcts(data.board, data.color, data.SIZE, data.timeLimit, data.maxDepth); self.postMessage({choice:choice}); }catch(e){ self.postMessage({error:String(e)}); } };
      `;
      const blob = new Blob([workerCode], {type: 'application/javascript'});
      const url = URL.createObjectURL(blob);
      searchWorker = new Worker(url);
      // send data to worker
      searchWorker.postMessage({ board: board.slice(), SIZE: SIZE, WHITE: WHITE, BLACK: BLACK, ARROW: ARROW, EMPTY: EMPTY, color: color, timeLimit: aiTimeLimit, maxDepth: aiMaxDepth });
      searchWorker.onmessage = function(ev){
        try{ URL.revokeObjectURL(url); }catch(e){}
        const data = ev.data;
        // terminate worker reference
        try{ searchWorker.terminate(); }catch(e){}
        searchWorker = null;
        if(myRun !== runId) return; // outdated
        if(gameOver) return;
        if(data && data.choice){
          const choice = data.choice;
          if(!choice){ // fallback random
            const fallback = moves[Math.floor(Math.random()*moves.length)];
            performAIMove(fallback, color, myRun);
          } else {
            performAIMove(choice, color, myRun);
          }
        } else {
          // error or no choice
          const fallback = moves[Math.floor(Math.random()*moves.length)];
          performAIMove(fallback, color, myRun);
        }
      };
      searchWorker.onerror = function(err){ try{ searchWorker.terminate(); }catch(e){} searchWorker = null; const fallback = moves[Math.floor(Math.random()*moves.length)]; performAIMove(fallback, color, myRun); };
    }

    // --- Online (Ably) integration ---
    // Replace with your Ably API key or provide token auth in production
    const ABLY_API_KEY = 'rDsQmg.lM8j3g:QNUsaMl2R1_1lxwnTk5HqDxOdIadTyTxNf9jRUPcoxA'; // <-- PUT YOUR ABLY API KEY HERE

    async function startOnline(key){
      if(onlineEnabled) return;
      onlineEnabled = true; onlineRoom = key;
      // disable AI for online matches
      aiEnabled = false; aiBoth = false;
      try{
        onlineAbly = new Ably.Realtime({ key: ABLY_API_KEY });
      }catch(e){ console.error('Ably init failed', e); alert('Ably init failed'); return; }
      onlineChannel = onlineAbly.channels.get('room:' + onlineRoom);

      // subscribe for join/iam/leave/move similar to demo
      onlineChannel.subscribe('join', msg => {
        const d = msg.data || {};
        const id = d.from;
        console.log('online join from', id);
        // reply
        onlineChannel.publish('iam', {from: onlineClientId, ts: Date.now()});
        if(!onlinePeers.has(id) && id!==onlineClientId) onlinePeers.set(id, Date.now());
        updateOnlineStatus();
        // if we now have exactly one peer (others length 1) and we were already present earlier,
        // and we are the earlier participant (onlinePeers had been empty before this join), decide roles
        tryAssignRolesOnSecondJoin();
      });
      onlineChannel.subscribe('iam', msg => {
        const d = msg.data || {};
        const id = d.from;
        console.log('online iam from', id);
        if(id!==onlineClientId) onlinePeers.set(id, Date.now());
        updateOnlineStatus();
        // try to assign roles if second peer is present (also handle case where we receive iam)
        tryAssignRolesOnSecondJoin();
      });
      onlineChannel.subscribe('leave', msg => {
        const d = msg.data || {};
        const id = d.from;
        console.log('online leave from', id);
        onlinePeers.delete(id); updateOnlineStatus();
      });
      onlineChannel.subscribe('move', msg => {
        const d = msg.data || {};
        if(d.fromClient === onlineClientId) return; // ignore own
        console.log('received remote move', d);
        applyRemoteMove(d);
      });
      onlineChannel.subscribe('resign', msg => {
        const d = msg.data || {};
        const loser = d.loser || d.from;
        console.log('received remote resign', d);
        // if someone else resigned, we win (if we are a participant)
        if(loser !== onlineClientId){
          if(onlineLocalColor){
            showOverlay('游戏结束', '你赢了！');
          } else {
            showOverlay('游戏结束', '胜者：对方认输');
          }
        }
        gameStarted = false;
      });
      onlineChannel.subscribe('start', msg => {
        const d = msg.data || {};
        console.log('received start', d);
        onlineStarted = true;
        // set local colors and starter
        if(d.white === onlineClientId) onlineLocalColor = WHITE;
        else if(d.black === onlineClientId) onlineLocalColor = BLACK;
        else onlineLocalColor = null; // spectator
        // determine if we are starter
        const starterId = d.starter;
        // set current player to white
        currentPlayer = WHITE;
        gameStarted = true;
        // show online info and current-turn display
        if(!onlineLocalColor){
          // spectator
          isMyTurn = false;
          onlineInfoEl.style.display = 'inline-block';
          onlineInfoEl.textContent = '联机房间 ' + onlineRoom + '，观战';
          // spectators see only exit button
          try{ resignBtn.style.display = 'none'; exitOnlineBtn.style.display = 'inline-block'; }catch(e){}
          statusEl.style.display = 'inline-block';
          statusEl.textContent = '当前回合：' + (currentPlayer===WHITE? '白方 ♕' : '黑方 ♛');
        } else {
          // participant
          isMyTurn = (starterId === onlineClientId);
          onlineInfoEl.style.display = 'inline-block';
          onlineInfoEl.textContent = '联机房间 ' + onlineRoom + '，您是' + (onlineLocalColor===WHITE? '白方':'黑方');
          statusEl.style.display = 'inline-block';
          statusEl.textContent = '当前回合：' + (currentPlayer===WHITE? '白方 ♕' : '黑方 ♛');
          resignBtn.style.display = 'inline-block';
          // hide selectors and start/online buttons
          try{ document.getElementById('mode').parentElement.style.display = 'none'; document.getElementById('level').parentElement.style.display = 'none'; }catch(e){}
          startBtn.style.display = 'none';
          onlineBtn.style.display = 'none';
          // participants do not see exit button
          try{ exitOnlineBtn.style.display = 'none'; }catch(e){}
        }
      });

      // hide local selectors: in online mode players don't choose mode/AI (hide whole label)
      try{ document.getElementById('mode').parentElement.style.display = 'none'; document.getElementById('level').parentElement.style.display = 'none'; }catch(e){}
      // announce and heartbeat (tolerant to publish errors)
      try{ onlineChannel.publish('join', {from: onlineClientId, ts: Date.now()}); }catch(e){}
      onlineHeartbeat = setInterval(()=>{ try{ onlineChannel.publish('join', {from: onlineClientId, ts: Date.now()}); }catch(e){}; pruneOnlinePeers(); }, 5000);
      updateOnlineStatus();
      // show online info in lobby and hide exit button (exit only for spectators)
      try{ onlineInfoEl.style.display = 'inline-block'; onlineInfoEl.textContent = '联机房间 ' + onlineRoom + '，等待其他玩家加入'; }catch(e){}
      try{ startBtn.style.display = 'none'; onlineBtn.style.display = 'none'; exitOnlineBtn.style.display = 'none'; }catch(e){}
    }

    function pruneOnlinePeers(){
      const now = Date.now();
      for(const [id, ts] of onlinePeers){ if(now - ts > 15000) onlinePeers.delete(id); }
      updateOnlineStatus();
    }

    function tryAssignRolesOnSecondJoin(){
      // Only start if we haven't already started the room
      if(onlineStarted) return;
      const participants = [onlineClientId].concat(Array.from(onlinePeers.keys())).filter(Boolean);
      // only auto-start when exactly two participants present
      if(participants.length !== 2) return;
      // deterministically pick the smallest id to publish the start to avoid races
      participants.sort();
      const leader = participants[0];
      const other = participants[1];
      if(onlineClientId !== leader) return;
      // leader publishes role assignment and starter
      const assignWhiteToUs = Math.random() < 0.5;
      const whiteId = assignWhiteToUs ? onlineClientId : other;
      const blackId = assignWhiteToUs ? other : onlineClientId;
      const starter = (Math.random() < 0.5) ? whiteId : blackId;
      const msg = {white: whiteId, black: blackId, starter: starter, ts: Date.now()};
      try{ onlineChannel.publish('start', msg); onlineStarted = true; console.log('published start', msg); }catch(e){ console.error('publish start err', e); }
    }

    // handle start message
    // ensure we subscribe earlier in startOnline: add a handler here
    // (we subscribe in startOnline - but ensure handler exists in file scope)

    function updateOnlineStatus(){
      const others = Array.from(onlinePeers.keys());
      const n = others.length + 1; // include self
      // if not started yet, show waiting/观战 state
      if(!gameStarted){
        if(n > 2){
          statusEl.textContent = '联机房间 ' + (onlineRoom||'') + '，观战';
        } else {
          statusEl.textContent = '联机房间 ' + (onlineRoom||'') + '，等待其他玩家加入';
        }
      } else {
        // match started — do not overwrite the current-turn display; keep status showing current turn
        updateStatus();
      }
        // no small event log; we show online info separately
        // nothing to do here
    }


    function applyRemoteMove(d){
      // apply move sent by remote: {from,to,arrow,fromClient}
      const from = d.from, to = d.to, arrow = d.arrow;
      // determine opponent color
      const opponentColor = (onlineLocalColor === WHITE) ? BLACK : WHITE;
      // apply: clear from, set to, set arrow
      board[from] = EMPTY;
      board[to] = opponentColor;
      board[arrow] = ARROW;
      // after remote move, it's our turn
      currentPlayer = onlineLocalColor;
      // allow local player to move
      gameStarted = true;
      isMyTurn = true;
      render();
      checkGameOverAndMaybeTriggerAI();
    }

    function stopOnline(){
      if(onlineHeartbeat) clearInterval(onlineHeartbeat);
      try{ if(onlineChannel) onlineChannel.publish('leave', {from: onlineClientId, ts: Date.now()}); }catch(e){}
      try{ if(onlineAbly) onlineAbly.close(); }catch(e){}
      onlineEnabled = false; onlineRoom = null; onlineChannel = null; onlinePeers.clear(); onlineAbly = null;
      statusEl.textContent = '当前回合：' + (currentPlayer===WHITE? '白方 ♕' : '黑方 ♛');
      onlineStarted = false;
      try{ exitOnlineBtn.style.display = 'none'; startBtn.style.display = 'inline-block'; onlineBtn.style.display = 'inline-block';
        // hide online info and status
        try{ onlineInfoEl.style.display = 'none'; }catch(e){}
        try{ statusEl.style.display = 'none'; }catch(e){}
        // restore mode/level parent labels
        try{ document.getElementById('mode').parentElement.style.display = ''; document.getElementById('level').parentElement.style.display = ''; }catch(e){}
      }catch(e){}
    }

    function performAIMove(choice, color, myRun){
      if(myRun !== runId) return;
      if(isAnimating) return;
      isAnimating = true;
      animateMove(choice.from, choice.to, color, ()=>{
        if(myRun!==runId){ isAnimating=false; return; }
        board[choice.to] = color;
        board[choice.from] = EMPTY;
        board[choice.arrow] = ARROW;
        currentPlayer = (color===WHITE)? BLACK : WHITE;
        isAnimating = false;
        render();
        checkGameOverAndMaybeTriggerAI();
      });
    }

    // legacy single-color wrapper (keeps compatibility)
    function aiMove(){ if(aiColor) aiMoveFor(aiColor); }

    // init
    setModeFromUI();
    setLevelFromUI();
    setupInitial();
    // restore initial UI state for local usage
    try{ resetUIForInitial(); }catch(e){ }

    // 统一取消：终止AI计时、搜索与动画，避免“重新开局”竞态
    function cancelAllAsync(){
      try{ if(aiTimer){ clearTimeout(aiTimer); aiTimer = null; } }catch(e){}
      try{ if(searchWorker){ searchWorker.terminate(); searchWorker = null; } }catch(e){}
      try{ if(animTimer){ clearTimeout(animTimer); animTimer = null; } }catch(e){}
      try{ $('.moving-piece').stop(true,true).remove(); }catch(e){}
      isAnimating = false;
    }
  })();
  </script>
</body>
</html>
