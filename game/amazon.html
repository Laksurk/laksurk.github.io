<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Amazons</title>
  <style>
    :root{--size:60px;--light:#f0d9b5;--dark:#b58863;--highlight:#ffe066}
    body{font-family:system-ui,Segoe UI,Arial;display:flex;flex-direction:column;align-items:center;padding:18px}
    h1{margin:6px 0 12px}
    #controls{margin-bottom:8px;display:flex;gap:10px;align-items:center}
    button{padding:6px 10px;font-size:14px}
    #status{font-weight:600}
    .board{display:grid;grid-template-columns:repeat(8, var(--size));grid-template-rows:repeat(8,var(--size));border:4px solid #444;position:relative}
    .cell{width:var(--size);height:var(--size);display:flex;align-items:center;justify-content:center;font-size:28px;cursor:pointer;user-select:none;position:relative}
    .piece{width:36px;height:36px;border-radius:50%;display:inline-block;box-sizing:border-box}
    .piece.white{background:#fff;border:2px solid #ddd}
    .piece.black{background:#222;border:2px solid #111}
    .cell.light{background:var(--light)}
    .cell.dark{background:var(--dark)}
    .cell.available{box-sizing:border-box}
    .cell.available::after{content:'';position:absolute;inset:0;background:rgba(0,0,0,0.12);pointer-events:none;border-radius:0}
    .cell.arrow{color:#444}
    .cell.blocked{color:inherit}
    .cell.blocked::after{content:'×';position:absolute; font-size:44px;line-height:1;left:50%;top:50%;transform:translate(-50%,-50%);background:none;pointer-events:none;border:0;padding:0;margin:0}
    /* make × contrast with the underlying checker color and slightly larger */
    .cell.light.blocked::after{color:#444;font-size:50px}
    .cell.dark.blocked::after{color:#444;font-size:50px;text-shadow:0 1px 0 rgba(0,0,0,0.15)}
    .moving-piece{position:absolute;z-index:60;pointer-events:none}
    /* overlay modal when game over */
    .overlay{position:fixed;inset:0;background:rgba(0,0,0,0.45);display:flex;align-items:center;justify-content:center;z-index:80;visibility:hidden;opacity:0;transition:opacity 200ms}
    .overlay.show{visibility:visible;opacity:1}
    .modal{background:#fff;padding:18px 22px;border-radius:10px;box-shadow:0 8px 24px rgba(0,0,0,0.25);min-width:260px;text-align:center}
    .modal h2{margin:0 0 8px;font-size:18px}
    .modal button{margin-top:8px}
    .legend{margin-top:12px;font-size:14px}
    /* Responsive adjustments for small screens */
    .board{width:calc(var(--size) * 8);height:calc(var(--size) * 8);}
    @media (max-width: 600px){
      :root{--size: calc((100vw - 36px) / 8);} /* fit 8 cells into viewport with some padding */
      body{padding:10px}
      .modal{min-width:unset;width:90%;padding:14px}
      .legend{font-size:13px}
      .cell{font-size:22px}
      .piece{width:calc(var(--size) * 0.6);height:calc(var(--size) * 0.6)}
    }
  </style>
  <script src="../src/jquery.min.js"></script>
</head>
<body>
  <h1>Amazons</h1>
  <div id="controls">
    <div id="status">当前回合：白方 ♕</div>
    <label>模式: <select id="mode"><option value="pve_first">单人（玩家先手）</option><option value="pve_second">单人（玩家后手）</option><option value="pvp">双人</option><option value="ai_vs_ai">电脑对局</option></select></label>
    <label>AI难度: <select id="level"><option value="easy">简单</option><option value="medium" selected>中等</option><option value="hard">困难</option></select></label>
    <button id="reset">重新开局</button>
  </div>
  <div id="board" class="board" role="application" aria-label="Amazon 棋盘"></div>
  <div class="legend">提示：先点击你的棋子，点击目标位置移动，然后点击放置障碍的位置。</div>

  <div id="overlay" class="overlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true">
      <h2 id="overlay-title">游戏结束</h2>
      <div id="overlay-msg">胜者：黑方</div>
      <div style="margin-top:10px"><button id="overlay-reset">重新开始</button></div>
    </div>
  </div>

  <script>
  (function(){
    const SIZE = 8;
    const EMPTY = 0, WHITE = 1, BLACK = 2, ARROW = 3;
    const boardEl = document.getElementById('board');
    const statusEl = document.getElementById('status');
    const resetBtn = document.getElementById('reset');

    let board = new Array(SIZE*SIZE).fill(EMPTY);
    let currentPlayer = WHITE; // WHITE starts
    let selected = null; // selected amazon index during move
    let phase = 'select'; // 'select' | 'arrow'
    let aiEnabled = false;
    let aiColor = BLACK; // which color AI plays when aiEnabled
    let aiDelay = 0; // ms delay before AI moves（避免重置后立刻阻塞UI）
    let aiTimeLimit = 1200; // ms for search budget
    let aiMaxDepth = 3;     // maximum search depth
    let gameOver = false;
    let isAnimating = false;
    let runId = 0; // 每次新开局自增，旧回调失效
    let aiTimer = null; // 待触发的AI计时器
    let animTimer = null; // 动画兜底计时器
    let searchWorker = null; // Web Worker for AI search

    function idx(r,c){return r*SIZE+c}
    function rc(i){return [Math.floor(i/SIZE), i%SIZE]}

    function setupInitial(){
      runId++;
      cancelAllAsync();
      board.fill(EMPTY);
      // Place 4 white amazons at positions specified by user (0-based): (0,2),(2,0),(0,5),(2,7)
      const whites = [[0,2],[2,0],[0,5],[2,7]];
      // horizontal symmetry (flip rows) for black pieces
      const blacks = whites.map(([r,c]) => [7 - r, c]);
      for(const [r,c] of whites) board[idx(r,c)] = WHITE;
      for(const [r,c] of blacks) board[idx(r,c)] = BLACK;
      currentPlayer = WHITE; selected = null; phase='select'; gameOver=false; isAnimating=false;
      render();
      // if AI plays first, trigger
      checkGameOverAndMaybeTriggerAI();
    }

    function render(){
      boardEl.innerHTML = '';
      for(let r=0;r<SIZE;r++){
        for(let c=0;c<SIZE;c++){
          const i = idx(r,c);
          const cell = document.createElement('div');
          cell.className = 'cell '+(((r+c)%2===0)?'light':'dark');
          cell.dataset.index = i;
          if(board[i]===WHITE){
            const p = document.createElement('span'); p.className = 'piece white'; cell.appendChild(p);
          } else if(board[i]===BLACK){
            const p = document.createElement('span'); p.className = 'piece black'; cell.appendChild(p);
          } else if(board[i]===ARROW){
            // keep blocked background but remove dot
            cell.classList.add('blocked');
          }
          boardEl.appendChild(cell);
        }
      }
      updateStatus();
    }

    function showOverlay(title,msg){
      const ov = document.getElementById('overlay');
      document.getElementById('overlay-title').textContent = title;
      document.getElementById('overlay-msg').textContent = msg;
      ov.classList.add('show'); ov.setAttribute('aria-hidden','false');
      // visually disable board
      boardEl.style.filter = 'brightness(0.75)';
      boardEl.style.pointerEvents = 'none';
    }

    function hideOverlay(){
      const ov = document.getElementById('overlay');
      ov.classList.remove('show'); ov.setAttribute('aria-hidden','true');
      boardEl.style.filter = ''; boardEl.style.pointerEvents = '';
    }

    let aiBoth = false; // when true both sides are AI
    function setModeFromUI(){
      const mode = document.getElementById('mode').value;
      aiBoth = false;
      if(mode === 'pvp') { aiEnabled = false; aiColor = null; }
      else if(mode === 'pve_first') { aiEnabled = true; aiBoth = false; aiColor = BLACK; }
      else if(mode === 'pve_second') { aiEnabled = true; aiBoth = false; aiColor = WHITE; }
      else if(mode === 'ai_vs_ai') { aiEnabled = true; aiBoth = true; aiColor = null; }
    }

    function setLevelFromUI(){
      const lv = document.getElementById('level').value;
      if(lv === 'easy'){ aiTimeLimit = 600; aiMaxDepth = 2; }
      else if(lv === 'medium'){ aiTimeLimit = 1200; aiMaxDepth = 3; }
      else { aiTimeLimit = 2000; aiMaxDepth = 4; }
    }

    function updateStatus(){
      statusEl.textContent = '当前回合：' + (currentPlayer===WHITE? '白方 ♕' : '黑方 ♛');
    }

    const DIRS = [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[-1,1],[1,-1],[1,1]];

    function slidesFrom(i, boardState){
      const [r,c] = rc(i);
      const moves = [];
      for(const [dr,dc] of DIRS){
        let nr=r+dr, nc=c+dc;
        while(nr>=0 && nr<SIZE && nc>=0 && nc<SIZE){
          const ni = idx(nr,nc);
          if(boardState[ni] !== EMPTY) break;
          moves.push(ni);
          nr += dr; nc += dc;
        }
      }
      return moves;
    }

    function highlight(list){
      // clear first
      document.querySelectorAll('.cell').forEach(el=>el.classList.remove('available'));
      for(const i of list){
        const el = boardEl.querySelector(`[data-index='${i}']`);
        if(el) el.classList.add('available');
      }
    }

    function clearHighlights(){
      document.querySelectorAll('.cell').forEach(el=>el.classList.remove('available'));
    }

    function handleCellClick(i){
      if(gameOver) return;
      if(aiEnabled && currentPlayer === aiColor) return; // block human input on AI's turn
      if(isAnimating) return;
      if(phase === 'select'){
        if(board[i] === currentPlayer){
          // clicking the same selected piece cancels selection
          if(selected === i){
            selected = null; clearHighlights();
          } else {
            selected = i;
            const moves = slidesFrom(i, board);
            highlight(moves);
          }
        } else {
          // if clicked an already highlighted move (move target), perform move (animated)
          const el = boardEl.querySelector(`[data-index='${i}']`);
          if(el && el.classList.contains('available') && selected !== null){
            // animated move: from `selected` to `i`
            if(isAnimating) return;
            isAnimating = true;
            const myRun = runId;
            animateMove(selected, i, currentPlayer, ()=>{
              if(myRun!==runId){ isAnimating=false; return; }
              // after move completes, occupy destination and enter arrow phase
              board[i] = currentPlayer;
              board[selected] = EMPTY;
              selected = i; // new position before arrow
              phase = 'arrow';
              // compute arrow moves from new pos (treating board as is: amazon occupies new pos)
              const arrows = slidesFrom(selected, board);
              highlight(arrows);
              renderCellsOnly();
              isAnimating = false;
            });
          } else {
            // clicked elsewhere -> cancel selection
            selected = null; clearHighlights();
          }
        }
      } else if(phase === 'arrow'){
        const el = boardEl.querySelector(`[data-index='${i}']`);
        if(el && el.classList.contains('available')){
          // place arrow
          board[i] = ARROW;
          selected = null; phase = 'select';
          clearHighlights();
          currentPlayer = (currentPlayer === WHITE)? BLACK : WHITE;
          render();
          // after switching player, check game over or let AI move
          checkGameOverAndMaybeTriggerAI();
        } else if (i === selected) {
          // clicked the amazon's current square -> ignore and remain in arrow phase
        } else {
          // clicked an illegal square while in arrow phase -> do nothing
          // preserve moved amazon, keep phase='arrow' and highlights
        }
      }
      // avoid re-rendering the board while a piece animation is active
      if(!isAnimating) renderCellsOnly();
    }

    function checkGameOverAndMaybeTriggerAI(){
      if(gameOver) return;
      const moves = getAllLegalMoves(currentPlayer, board);
      if(moves.length === 0){
        gameOver = true;
        const winner = (currentPlayer===WHITE? '黑方' : '白方');
        statusEl.textContent = '游戏结束：' + winner + ' 胜';
        showOverlay('游戏结束', '胜者：' + winner);
        return;
      }
      if(!aiEnabled) return;
      // 清理旧的AI计时
      if(aiTimer){ clearTimeout(aiTimer); aiTimer = null; }
      const myRun = runId;
      const schedule = (color)=>{
        aiTimer = setTimeout(()=>{ if(myRun===runId && !gameOver) aiMoveFor(color); }, aiDelay);
      };
      if(aiBoth){
        schedule(currentPlayer);
      } else if(currentPlayer === aiColor){
        schedule(aiColor);
      }
    }

    function renderCellsOnly(){
      // update each cell content and classes without rebuilding whole DOM (to preserve highlights)
      for(let i=0;i<SIZE*SIZE;i++){
        const el = boardEl.querySelector(`[data-index='${i}']`);
        if(!el) continue;
        el.classList.remove('blocked');
        el.innerHTML = '';
        if(board[i]===WHITE){ const p = document.createElement('span'); p.className='piece white'; el.appendChild(p); }
        else if(board[i]===BLACK){ const p = document.createElement('span'); p.className='piece black'; el.appendChild(p); }
        else if(board[i]===ARROW){ el.classList.add('blocked'); }
        else { /* empty */ }
      }
      updateStatus();
    }

    boardEl.addEventListener('click', (ev)=>{
      const cell = ev.target.closest('.cell');
      if(!cell) return;
      const i = Number(cell.dataset.index);
      handleCellClick(i);
    });

    resetBtn.addEventListener('click', ()=>{ cancelAllAsync(); hideOverlay(); setupInitial(); });
    document.getElementById('mode').addEventListener('change', ()=>{ setModeFromUI(); });
    document.getElementById('level').addEventListener('change', ()=>{ setLevelFromUI(); });
    document.getElementById('overlay-reset').addEventListener('click', ()=>{ cancelAllAsync(); hideOverlay(); setupInitial(); });

    // AI helpers
    function cloneBoard(b){ return b.slice(); }

    function getAmazons(color, b){
      const res = [];
      for(let i=0;i<b.length;i++) if(b[i]===color) res.push(i);
      return res;
    }

    function getAllLegalMoves(color, b){
      const res = [];
      const amazons = getAmazons(color, b);
      for(const from of amazons){
        const slides = slidesFrom(from, b);
        for(const to of slides){
          // simulate moving amazon to 'to'
          const tmp = cloneBoard(b);
          tmp[from] = EMPTY; tmp[to] = color;
          const arrows = slidesFrom(to, tmp);
          for(const arrow of arrows){
            res.push({from,to,arrow});
          }
        }
      }
      return res;
    }

    // animation helpers
    function getCellElement(i){ return boardEl.querySelector(`[data-index='${i}']`); }
    function animateMove(from,to,color,cb){
      const $src = $($(getCellElement(from)));
      const $dst = $($(getCellElement(to)));
      if($src.length === 0 || $dst.length === 0){ cb && cb(); return; }
      const srcPiece = $src.find('.piece');
      // compute start/end coordinates in page space
      // use jQuery offsets (document coordinates) to account for scrolling/viewport
      const srcOffset = srcPiece.length ? srcPiece.offset() : $src.offset();
      const dstPiece = $dst.find('.piece');
      const dstCellOffset = $dst.offset();
      const pieceW = srcPiece.length ? srcPiece.outerWidth() : ($src.find('.piece').outerWidth() || $src.outerWidth());
      const pieceH = srcPiece.length ? srcPiece.outerHeight() : ($src.find('.piece').outerHeight() || $src.outerHeight());
      const $moving = $('<span>').addClass('piece ' + (color===WHITE? 'white':'black') + ' moving-piece');
      // set explicit size and absolute page-positioning (use document coordinates)
      $moving.css({position:'absolute', left: srcOffset.left + 'px', top: srcOffset.top + 'px', width: pieceW + 'px', height: pieceH + 'px', 'z-index': 9999});
      // append to body so page coords match
      $(document.body).append($moving);
      // hide original piece visually (keep in DOM to avoid layout change)
      if(srcPiece.length) srcPiece.css('visibility','hidden');
      else $src.find('.piece').css('visibility','hidden');
      // determine destination coordinates: prefer inner piece offset, otherwise center in cell
      let dstLeft, dstTop;
      if(dstPiece.length){
        const dstPieceOffset = dstPiece.offset();
        dstLeft = dstPieceOffset.left;
        dstTop = dstPieceOffset.top;
      } else {
        dstLeft = dstCellOffset.left + ( $dst.outerWidth() - pieceW )/2;
        dstTop = dstCellOffset.top + ( $dst.outerHeight() - pieceH )/2;
      }
      // animate using jQuery built-in .animate on page coords
      const duration = 300; // doubled duration for smoother, slower animation
      $moving.animate({left: dstLeft + 'px', top: dstTop + 'px'}, duration, 'swing', function(){
        // cleanup
        $moving.remove();
        if(srcPiece.length) srcPiece.css('visibility','');
        // call callback (caller will update board state and re-render)
        cb && cb();
      });
      // safety fallback
      if(animTimer) try{ clearTimeout(animTimer); }catch(e){}
      animTimer = setTimeout(()=>{ if($.contains(document, $moving[0])){ $moving.remove(); if(srcPiece.length) srcPiece.css('visibility',''); cb && cb(); } }, duration + 600);
    }

    function aiMoveFor(color){
      if(gameOver) return;
      const moves = getAllLegalMoves(color, board);
      if(moves.length===0){ checkGameOverAndMaybeTriggerAI(); return; }
      // 取消之前的 worker（若在运行）
      if(searchWorker){ try{ searchWorker.terminate(); }catch(e){} searchWorker = null; }
      const myRun = runId;
      // 构建 worker 代码（使用蒙特卡洛树搜索 MCTS）
      const workerCode = `
        const DIRS = [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[-1,1],[1,-1],[1,1]];
        function idx(r,c,s){return r*s+c}
        function rc(i,s){return [Math.floor(i/s), i%s]}
        function slidesFrom(i, boardState, SIZE, EMPTY){
          const [r,c] = rc(i,SIZE);
          const moves = [];
          for(const [dr,dc] of DIRS){
            let nr=r+dr, nc=c+dc;
            while(nr>=0 && nr<SIZE && nc>=0 && nc<SIZE){
              const ni = idx(nr,nc,SIZE);
              if(boardState[ni] !== EMPTY) break;
              moves.push(ni);
              nr += dr; nc += dc;
            }
          }
          return moves;
        }
        function cloneBoard(b){ return b.slice(); }
        function getAmazons(color, b){ const res=[]; for(let i=0;i<b.length;i++) if(b[i]===color) res.push(i); return res; }
        function applyMoveTo(boardSrc, mv, color){ const tmp = cloneBoard(boardSrc); tmp[mv.from]=0; tmp[mv.to]=color; tmp[mv.arrow]=3; return tmp; }
        function getAllLegalMoves(color, b, SIZE){ const res=[]; const amazons = getAmazons(color,b); for(const from of amazons){ const slides=slidesFrom(from,b,SIZE,0); for(const to of slides){ const tmp=cloneBoard(b); tmp[from]=0; tmp[to]=color; const arrows=slidesFrom(to,tmp,SIZE,0); for(const arrow of arrows){ res.push({from,to,arrow}); } } } return res; }

        // Random playout (returns 1 if rootColor wins, 0 otherwise)
        // Modified: 随机走直到出现不可通行的分区（所有连通分区不再同时包含双方棋子），
        // 然后按各自“占有”的格子数判断胜负；若平局则以下一手玩家决定胜负。
        function randomPlayout(board, toMove, rootColor, SIZE){
          let b = cloneBoard(board);
          let player = toMove;
          while(true){
            const moves = getAllLegalMoves(player, b, SIZE);
            if(moves.length === 0){
              // 当前玩家无路可走，另一方获胜
              return (player === rootColor) ? 0 : 1;
            }
            // 随机走一步
            const mv = moves[Math.floor(Math.random()*moves.length)];
            b = applyMoveTo(b, mv, player);

            // 检测基于 8 邻域的连通分区（把 ARROW 视为阻隔）
            const visited = new Array(SIZE*SIZE).fill(false);
            let partitioned = true;
            let whiteArea = 0, blackArea = 0;
            for(let i=0;i<SIZE*SIZE;i++){
              if(visited[i]) continue;
              if(b[i] === 3) continue; // ARROW
              // BFS / DFS 收集连通分区
              const stack = [i]; visited[i] = true;
              let compSize = 0;
              let hasWhite = false, hasBlack = false;
              while(stack.length){
                const cur = stack.pop();
                compSize++;
                if(b[cur] === 1) hasWhite = true;
                else if(b[cur] === 2) hasBlack = true;
                const rcPair = rc(cur, SIZE);
                const r = rcPair[0], c = rcPair[1];
                for(const d of DIRS){
                  const nr = r + d[0], nc = c + d[1];
                  if(nr>=0 && nr<SIZE && nc>=0 && nc<SIZE){
                    const ni = idx(nr,nc,SIZE);
                    if(!visited[ni] && b[ni] !== 3){ visited[ni] = true; stack.push(ni); }
                  }
                }
              }
              if(hasWhite && hasBlack){ partitioned = false; break; }
              if(hasWhite) whiteArea += compSize;
              else if(hasBlack) blackArea += compSize;
            }

            if(partitioned){
              if(whiteArea > blackArea) return (rootColor === 1) ? 1 : 0;
              if(blackArea > whiteArea) return (rootColor === 2) ? 1 : 0;
              // 平局：以下一手玩家（即当前走子后的对方）决定胜负
              const nextPlayer = (player === 1 ? 2 : 1);
              return (nextPlayer === rootColor) ? 1 : 0;
            }

            player = (player===1?2:1);
          }
        }

        // MCTS Node
        function Node(parent, move, playerWhoMoved, board){
          this.parent = parent || null;
          this.move = move || null; // move that led to this node
          this.playerWhoMoved = playerWhoMoved || null;
          this.board = board || null;
          this.children = [];
          this.untriedMoves = null;
          this.wins = 0;
          this.visits = 0;
        }

        Node.prototype.expand = function(move, nextBoard, nextPlayer){
          const child = new Node(this, move, nextPlayer, nextBoard);
          this.children.push(child);
          return child;
        };

        Node.prototype.isFullyExpanded = function(){ return this.untriedMoves && this.untriedMoves.length === 0; };

        Node.prototype.bestChild = function(cParam){
          let best = null; let bestU = -Infinity;
          for(const ch of this.children){
            const u = (ch.wins / (ch.visits||1)) + cParam * Math.sqrt(2*Math.log(this.visits+1)/(ch.visits||1));
            if(u > bestU){ bestU = u; best = ch; }
          }
          return best;
        };

        function mcts(rootBoard, rootPlayer, SIZE, timeLimit, maxDepth){
          const start = Date.now();
          const root = new Node(null, null, (rootPlayer===1?2:1), rootBoard);
          root.untriedMoves = getAllLegalMoves(rootPlayer, rootBoard, SIZE);
          const C = 1.4;
          let iterations = 0;
          while(Date.now() - start < timeLimit){
            iterations++;
            // SELECTION
            let node = root;
            let player = rootPlayer;
            // descend
            while(node.untriedMoves && node.untriedMoves.length === 0 && node.children.length > 0){
              node = node.bestChild(C);
              player = (player===1?2:1);
            }
            // EXPANSION
            if(node.untriedMoves === null){
              node.untriedMoves = getAllLegalMoves(player, node.board, SIZE);
            }
            if(node.untriedMoves && node.untriedMoves.length > 0){
              // Weighted random selection among untried moves using mobility heuristic
              const movesList = node.untriedMoves;
              const weighted = [];
              let totalW = 0;
              for(let mi=0; mi<movesList.length; mi++){
                const mv = movesList[mi];
                const nb = applyMoveTo(node.board, mv, player);
                // mobility: 改为双方移动性之比 (playerMobility / opponentMobility)
                const amazonsP = getAmazons(player, nb);
                let mobP = 0;
                for(const a of amazonsP){ mobP += slidesFrom(a, nb, SIZE, 0).length; }
                const opp = (player===1?2:1);
                const amazonsO = getAmazons(opp, nb);
                let mobO = 0;
                for(const a of amazonsO){ mobO += slidesFrom(a, nb, SIZE, 0).length; }
                const diff = mobP - mobO;
                const w = Math.exp(diff / 20);
                console.log(w);
                weighted.push({mv, nb, w});
                totalW += w;
              }
              // pick by weighted roulette
              let pick = Math.random() * totalW;
              let chosen = null; let chosenIdx = -1;
              for(let k=0;k<weighted.length;k++){
                pick -= weighted[k].w;
                if(pick <= 0){ chosen = weighted[k]; chosenIdx = k; break; }
              }
              if(!chosen){ chosen = weighted[weighted.length-1]; chosenIdx = weighted.length-1; }
              // remove chosen.mv from node.untriedMoves
              const removeIndex = node.untriedMoves.indexOf(chosen.mv);
              if(removeIndex >= 0) node.untriedMoves.splice(removeIndex,1);
              const child = node.expand(chosen.mv, chosen.nb, player);
              node = child;
              player = (player===1?2:1);
            }
            // SIMULATION
            const result = randomPlayout(node.board || root.board, player, rootPlayer, SIZE);
            // BACKPROPAGATION
            let curr = node;
            while(curr !== null){
              curr.visits += 1;
              // if result is win for rootPlayer and child is in its line, add win
              curr.wins += result;
              curr = curr.parent;
            }
          }
          // choose best child by visits
          let best = null; let bestVisits = -1;
          for(const ch of root.children){ if(ch.visits > bestVisits){ bestVisits = ch.visits; best = ch; } }
          return best ? best.move : null;
        }

        self.onmessage = function(ev){ try{ const data = ev.data; const choice = mcts(data.board, data.color, data.SIZE, data.timeLimit, data.maxDepth); self.postMessage({choice:choice}); }catch(e){ self.postMessage({error:String(e)}); } };
      `;
      const blob = new Blob([workerCode], {type: 'application/javascript'});
      const url = URL.createObjectURL(blob);
      searchWorker = new Worker(url);
      // send data to worker
      searchWorker.postMessage({ board: board.slice(), SIZE: SIZE, WHITE: WHITE, BLACK: BLACK, ARROW: ARROW, EMPTY: EMPTY, color: color, timeLimit: aiTimeLimit, maxDepth: aiMaxDepth });
      searchWorker.onmessage = function(ev){
        try{ URL.revokeObjectURL(url); }catch(e){}
        const data = ev.data;
        // terminate worker reference
        try{ searchWorker.terminate(); }catch(e){}
        searchWorker = null;
        if(myRun !== runId) return; // outdated
        if(gameOver) return;
        if(data && data.choice){
          const choice = data.choice;
          if(!choice){ // fallback random
            const fallback = moves[Math.floor(Math.random()*moves.length)];
            performAIMove(fallback, color, myRun);
          } else {
            performAIMove(choice, color, myRun);
          }
        } else {
          // error or no choice
          const fallback = moves[Math.floor(Math.random()*moves.length)];
          performAIMove(fallback, color, myRun);
        }
      };
      searchWorker.onerror = function(err){ try{ searchWorker.terminate(); }catch(e){} searchWorker = null; const fallback = moves[Math.floor(Math.random()*moves.length)]; performAIMove(fallback, color, myRun); };
    }

    function performAIMove(choice, color, myRun){
      if(myRun !== runId) return;
      if(isAnimating) return;
      isAnimating = true;
      animateMove(choice.from, choice.to, color, ()=>{
        if(myRun!==runId){ isAnimating=false; return; }
        board[choice.to] = color;
        board[choice.from] = EMPTY;
        board[choice.arrow] = ARROW;
        currentPlayer = (color===WHITE)? BLACK : WHITE;
        isAnimating = false;
        render();
        checkGameOverAndMaybeTriggerAI();
      });
    }

    // legacy single-color wrapper (keeps compatibility)
    function aiMove(){ if(aiColor) aiMoveFor(aiColor); }

    // init
    setModeFromUI();
    setLevelFromUI();
    setupInitial();

    // 统一取消：终止AI计时、搜索与动画，避免“重新开局”竞态
    function cancelAllAsync(){
      try{ if(aiTimer){ clearTimeout(aiTimer); aiTimer = null; } }catch(e){}
      try{ if(searchWorker){ searchWorker.terminate(); searchWorker = null; } }catch(e){}
      try{ if(animTimer){ clearTimeout(animTimer); animTimer = null; } }catch(e){}
      try{ $('.moving-piece').stop(true,true).remove(); }catch(e){}
      isAnimating = false;
    }
  })();
  </script>
</body>
</html>
